From 4cfb43f37aa3fec66374e618d43f2f615a7d3e98 Mon Sep 17 00:00:00 2001
From: tisenu100 <tisenu100@github.com>
Date: Wed, 12 Feb 2025 15:00:13 +0200
Subject: [PATCH] sdfat: upstream to 2.8.1 from S918BXXS7CXL2

Updated SDFat which is required for OneUI 7
---
 arch/arm64/configs/a71_defconfig |  94 +++++-----
 fs/sdfat/Kconfig                 |  15 +-
 fs/sdfat/amap_smart.c            |  18 ++
 fs/sdfat/api.h                   |   1 +
 fs/sdfat/blkdev.c                |  19 ++-
 fs/sdfat/core.c                  |  96 +++++++++--
 fs/sdfat/core_exfat.c            |  12 +-
 fs/sdfat/core_fat.c              |   2 +
 fs/sdfat/misc.c                  |  35 ++--
 fs/sdfat/mpage.c                 |  41 ++++-
 fs/sdfat/sdfat.c                 | 284 ++++++++++++++++++++++++-------
 fs/sdfat/sdfat.h                 |   9 +-
 fs/sdfat/version.h               |   4 +-
 13 files changed, 463 insertions(+), 167 deletions(-)

diff --git a/arch/arm64/configs/a71_defconfig b/arch/arm64/configs/a71_defconfig
index de8620f788a1..3a2f47444198 100644
--- a/arch/arm64/configs/a71_defconfig
+++ b/arch/arm64/configs/a71_defconfig
@@ -5870,7 +5870,7 @@ CONFIG_SDFAT_DEFAULT_IOCHARSET="utf8"
 # CONFIG_SDFAT_CHECK_RO_ATTR is not set
 CONFIG_SDFAT_ALIGNED_MPAGE_WRITE=y
 # CONFIG_SDFAT_VIRTUAL_XATTR is not set
-CONFIG_SDFAT_SUPPORT_STLOG=y
+# CONFIG_SDFAT_SUPPORT_STLOG is not set
 # CONFIG_SDFAT_DEBUG is not set
 CONFIG_SDFAT_STATISTICS=y
 CONFIG_SDFAT_UEVENT=y
@@ -5952,53 +5952,53 @@ CONFIG_NETWORK_FILESYSTEMS=y
 CONFIG_NLS=y
 CONFIG_NLS_DEFAULT="iso8859-1"
 CONFIG_NLS_CODEPAGE_437=y
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_CODEPAGE_737=y
+CONFIG_NLS_CODEPAGE_775=y
+CONFIG_NLS_CODEPAGE_850=y
+CONFIG_NLS_CODEPAGE_852=y
+CONFIG_NLS_CODEPAGE_855=y
+CONFIG_NLS_CODEPAGE_857=y
+CONFIG_NLS_CODEPAGE_860=y
+CONFIG_NLS_CODEPAGE_861=y
+CONFIG_NLS_CODEPAGE_862=y
+CONFIG_NLS_CODEPAGE_863=y
+CONFIG_NLS_CODEPAGE_864=y
+CONFIG_NLS_CODEPAGE_865=y
+CONFIG_NLS_CODEPAGE_866=y
+CONFIG_NLS_CODEPAGE_869=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=y
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_CODEPAGE_949=y
+CONFIG_NLS_CODEPAGE_874=y
+CONFIG_NLS_ISO8859_8=y
+CONFIG_NLS_CODEPAGE_1250=y
+CONFIG_NLS_CODEPAGE_1251=y
+CONFIG_NLS_ASCII=y
 CONFIG_NLS_ISO8859_1=y
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_MAC_ROMAN is not set
-# CONFIG_NLS_MAC_CELTIC is not set
-# CONFIG_NLS_MAC_CENTEURO is not set
-# CONFIG_NLS_MAC_CROATIAN is not set
-# CONFIG_NLS_MAC_CYRILLIC is not set
-# CONFIG_NLS_MAC_GAELIC is not set
-# CONFIG_NLS_MAC_GREEK is not set
-# CONFIG_NLS_MAC_ICELAND is not set
-# CONFIG_NLS_MAC_INUIT is not set
-# CONFIG_NLS_MAC_ROMANIAN is not set
-# CONFIG_NLS_MAC_TURKISH is not set
+CONFIG_NLS_ISO8859_2=y
+CONFIG_NLS_ISO8859_3=y
+CONFIG_NLS_ISO8859_4=y
+CONFIG_NLS_ISO8859_5=y
+CONFIG_NLS_ISO8859_6=y
+CONFIG_NLS_ISO8859_7=y
+CONFIG_NLS_ISO8859_9=y
+CONFIG_NLS_ISO8859_13=y
+CONFIG_NLS_ISO8859_14=y
+CONFIG_NLS_ISO8859_15=y
+CONFIG_NLS_KOI8_R=y
+CONFIG_NLS_KOI8_U=y
+CONFIG_NLS_MAC_ROMAN=y
+CONFIG_NLS_MAC_CELTIC=y
+CONFIG_NLS_MAC_CENTEURO=y
+CONFIG_NLS_MAC_CROATIAN=y
+CONFIG_NLS_MAC_CYRILLIC=y
+CONFIG_NLS_MAC_GAELIC=y
+CONFIG_NLS_MAC_GREEK=y
+CONFIG_NLS_MAC_ICELAND=y
+CONFIG_NLS_MAC_INUIT=y
+CONFIG_NLS_MAC_ROMANIAN=y
+CONFIG_NLS_MAC_TURKISH=y
 CONFIG_NLS_UTF8=y
 # CONFIG_DLM is not set
 CONFIG_UNICODE=y
diff --git a/fs/sdfat/Kconfig b/fs/sdfat/Kconfig
index 62eb87bab6f6..6f970d21b6bd 100644
--- a/fs/sdfat/Kconfig
+++ b/fs/sdfat/Kconfig
@@ -1,10 +1,10 @@
 config SDFAT_FS
-	tristate
+	tristate "sdFAT support"
 	default y
 	select NLS
-	select NLS_UTF8
-	select NLS_CODEPAGE_437
-	select NLS_ISO8859_1
+#	select NLS_UTF8
+#	select NLS_CODEPAGE_437
+#	select NLS_ISO8859_1
 	help
 	  If you want to use the sdFAT file system, then you must say Y or M
 	  here to inlucde sdFAT support.
@@ -15,13 +15,6 @@ config SDFAT_FS
 	  To compile this as a module, choose M here: the module will be called
 	  sdfat_core and sdfat_fs.
 
-config SDFAT_USE_FOR_EXFAT
-	bool "Register sdFAT as exFAT"
-	default y
-	depends on SDFAT_FS && !EXFAT_FS
-	help
-	  If you want to register sdFAT as available for exFAT, say Y.
-
 config SDFAT_DELAYED_META_DIRTY
 	bool "Enable delayed metadata dirty"
 	default y
diff --git a/fs/sdfat/amap_smart.c b/fs/sdfat/amap_smart.c
index 8bfb22481374..baa580c834db 100644
--- a/fs/sdfat/amap_smart.c
+++ b/fs/sdfat/amap_smart.c
@@ -419,11 +419,20 @@ int amap_create(struct super_block *sb, u32 pack_ratio, u32 sect_per_au, u32 hid
 
 	/* Allocate AU info table */
 	n_au_table = (amap->n_au + N_AU_PER_TABLE - 1) / N_AU_PER_TABLE;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+	amap->au_table = kvmalloc(sizeof(AU_INFO_T *) * n_au_table, GFP_NOIO);
+#else
 	amap->au_table = kmalloc(sizeof(AU_INFO_T *) * n_au_table, GFP_NOIO);
+#endif
 	if (!amap->au_table) {
 		sdfat_msg(sb, KERN_ERR,
 			"failed to alloc amap->au_table\n");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+		kvfree(amap);
+#else
 		kfree(amap);
+#endif
 		return -ENOMEM;
 	}
 
@@ -554,7 +563,12 @@ int amap_create(struct super_block *sb, u32 pack_ratio, u32 sect_per_au, u32 hid
 			else
 				vfree(amap->fclu_nodes);
 		}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+		kvfree(amap);
+#else
 		kfree(amap);
+#endif
 	}
 	return -EIO;
 }
@@ -585,7 +599,11 @@ void amap_destroy(struct super_block *sb)
 		free_page((unsigned long)amap->fclu_nodes);
 	else
 		vfree(amap->fclu_nodes);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+	kvfree(amap);
+#else
 	kfree(amap);
+#endif
 	SDFAT_SB(sb)->fsi.amap = NULL;
 }
 
diff --git a/fs/sdfat/api.h b/fs/sdfat/api.h
index 344297ab58ae..8e7bf50c94f6 100644
--- a/fs/sdfat/api.h
+++ b/fs/sdfat/api.h
@@ -252,6 +252,7 @@ typedef struct {
 	u32      (*get_entry_clu0)(DENTRY_T *);
 	void     (*set_entry_clu0)(DENTRY_T *, u32);
 	u64      (*get_entry_size)(DENTRY_T *);
+	u64      (*get_entry_validsize)(DENTRY_T *);
 	void     (*set_entry_size)(DENTRY_T *, u64);
 	void     (*get_entry_time)(DENTRY_T *, TIMESTAMP_T *, u8);
 	void     (*set_entry_time)(DENTRY_T *, TIMESTAMP_T *, u8);
diff --git a/fs/sdfat/blkdev.c b/fs/sdfat/blkdev.c
index 788b7c034afc..34d275133f8d 100644
--- a/fs/sdfat/blkdev.c
+++ b/fs/sdfat/blkdev.c
@@ -104,6 +104,19 @@ s32 bdev_check_bdi_valid(struct super_block *sb)
 }
 
 #if IS_BUILTIN(CONFIG_SDFAT_FS)
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
+static inline void __sdfat_blk_flush_plug(void)
+{
+	blk_flush_plug(current->plug, false);
+}
+#else
+static inline void __sdfat_blk_flush_plug(void)
+{
+	blk_flush_plug(current);
+}
+#endif
+
 static void __bdev_readahead(struct super_block *sb, u64 secno, u64 num_secs)
 {
 	u32 sects_per_page = (PAGE_SIZE >> sb->s_blocksize_bits);
@@ -113,7 +126,7 @@ static void __bdev_readahead(struct super_block *sb, u64 secno, u64 num_secs)
 	blk_start_plug(&plug);
 	for (i = 0; i < num_secs; i++) {
 		if (i && !(i & (sects_per_page - 1)))
-			blk_flush_plug(current);
+			__sdfat_blk_flush_plug();
 		sb_breadahead(sb, (sector_t)(secno + i));
 	}
 	blk_finish_plug(&plug);
@@ -173,7 +186,9 @@ s32 bdev_mread(struct super_block *sb, u64 secno, struct buffer_head **bh, u64 n
 	if (!(fsi->prev_eio & SDFAT_EIO_READ)) {
 		fsi->prev_eio |= SDFAT_EIO_READ;
 		sdfat_log_msg(sb, KERN_ERR, "%s: No bh. I/O error.", __func__);
+#ifdef CONFIG_SDFAT_DEBUG
 		sdfat_debug_warn_on(1);
+#endif
 	}
 
 	return -EIO;
@@ -227,7 +242,9 @@ s32 bdev_mwrite(struct super_block *sb, u64 secno, struct buffer_head *bh, u64 n
 	if (!(fsi->prev_eio & SDFAT_EIO_WRITE)) {
 		fsi->prev_eio |= SDFAT_EIO_WRITE;
 		sdfat_log_msg(sb, KERN_ERR, "%s: No bh. I/O error.", __func__);
+#ifdef CONFIG_SDFAT_DEBUG
 		sdfat_debug_warn_on(1);
+#endif
 	}
 
 	return -EIO;
diff --git a/fs/sdfat/core.c b/fs/sdfat/core.c
index 1a87070548af..770fef879656 100644
--- a/fs/sdfat/core.c
+++ b/fs/sdfat/core.c
@@ -832,7 +832,7 @@ static s32 search_empty_slot(struct super_block *sb, HINT_FEMP_T *hint_femp, CHA
 static s32 find_empty_entry(struct inode *inode, CHAIN_T *p_dir, s32 num_entries)
 {
 	s32 dentry;
-	u32 ret, last_clu;
+	u32 ret, last_clu = CLUS_EOF;
 	u64 sector;
 	u64 size = 0;
 	CHAIN_T clu;
@@ -862,16 +862,28 @@ static s32 find_empty_entry(struct inode *inode, CHAIN_T *p_dir, s32 num_entries
 		if (fsi->fs_func->check_max_dentries(fid))
 			return -ENOSPC;
 
-		/* we trust p_dir->size regardless of FAT type */
-		if (__find_last_cluster(sb, p_dir, &last_clu))
-			return -EIO;
+		if (!IS_CLUS_EOF(p_dir->dir)) {
+			/* we trust p_dir->size regardless of FAT type */
+			if (__find_last_cluster(sb, p_dir, &last_clu))
+				return -EIO;
 
-		/*
-		 * Allocate new cluster to this directory
-		 */
-		clu.dir = last_clu + 1;
-		clu.size = 0; /* UNUSED */
-		clu.flags = p_dir->flags;
+			/*
+			 * Allocate new cluster to this directory
+			 */
+			clu.dir = last_clu + 1;
+			clu.size = 0; /* UNUSED */
+			clu.flags = p_dir->flags;
+		} else if (fsi->vol_type == EXFAT && p_dir->size == 0) {
+			/* This directory is empty, zero sized */
+			clu.dir = CLUS_EOF;
+			clu.size = 0; /* UNUSED */
+			clu.flags = 0x03;
+		} else {
+			/* Directory must not be zero sized */
+			DMSG("%s: bogus directory: no cluster, zero-size (p_dir : %u, entry : 0x%08x)",
+			     __func__, fid->dir.dir, fid->entry);
+			return -EIO;
+		}
 
 		/* (0) check if there are reserved clusters
 		 * (create_dir 의 주석 참고)
@@ -888,6 +900,9 @@ static s32 find_empty_entry(struct inode *inode, CHAIN_T *p_dir, s32 num_entries
 		if (__clear_cluster(inode, clu.dir))
 			return -EIO;
 
+		if (IS_CLUS_EOF(last_clu))
+			p_dir->dir = clu.dir;
+
 		/* (2) append to the FAT chain */
 		if (clu.flags != p_dir->flags) {
 			/* no-fat-chain bit is disabled,
@@ -924,6 +939,8 @@ static s32 find_empty_entry(struct inode *inode, CHAIN_T *p_dir, s32 num_entries
 					&(fid->dir), fid->entry+1, &sector);
 			if (!ep)
 				return -EIO;
+			if (IS_CLUS_EOF(last_clu))
+				fsi->fs_func->set_entry_clu0(ep, p_dir->dir);
 			fsi->fs_func->set_entry_size(ep, size);
 			fsi->fs_func->set_entry_flag(ep, p_dir->flags);
 			if (dcache_modify(sb, sector))
@@ -937,6 +954,7 @@ static s32 find_empty_entry(struct inode *inode, CHAIN_T *p_dir, s32 num_entries
 		i_size_write(inode, (loff_t)size);
 		SDFAT_I(inode)->i_size_ondisk += fsi->cluster_size;
 		SDFAT_I(inode)->i_size_aligned += fsi->cluster_size;
+		SDFAT_I(inode)->fid.start_clu = p_dir->dir;
 		SDFAT_I(inode)->fid.size = size;
 		SDFAT_I(inode)->fid.flags = p_dir->flags;
 		inode->i_blocks += 1 << (fsi->cluster_size_bits - sb->s_blocksize_bits);
@@ -2026,14 +2044,50 @@ s32 fscore_lookup(struct inode *inode, u8 *path, FILE_ID_T *fid)
 		fid->rwoffset = 0;
 		fid->hint_bmap.off = CLUS_EOF;
 		fid->attr = fsi->fs_func->get_entry_attr(ep);
+		fid->flags = fsi->fs_func->get_entry_flag(ep2);
+		fid->start_clu = fsi->fs_func->get_entry_clu0(ep2);
+
+		/*
+		 * NOTICE:
+		 * exFAT-spec does not allow validSize != size for directories.
+		 * However, it allows validSize != size for limited(tail) sparse
+		 * files. Unfortunatly, sdFAT does not have any plan to support
+		 * limited sparse files. So I just keep AS-IS policy for those
+		 * files, which exports validsize as its file size. If not, it
+		 * could make security issues that read old data instead of
+		 * zero-fill for range validSize ~ size.
+		 */
+		if (fsi->fs_func->get_entry_validsize) {
+			fid->size = fsi->fs_func->get_entry_validsize(ep2);
 
-		fid->size = fsi->fs_func->get_entry_size(ep2);
-		if ((fid->type == TYPE_FILE) && (fid->size == 0)) {
+			if (fid->size == 0 && fid->type == TYPE_DIR &&
+			    !IS_CLUS_FREE(fid->start_clu)) {
+				fid->size = fsi->fs_func->get_entry_size(ep2);
+			}
+		} else {
+			fid->size = fsi->fs_func->get_entry_size(ep2);
+		}
+
+		/* If type is DIR, make its size multiple of the cluster one */
+		if (fid->size && fid->type == TYPE_DIR) {
+			u64 num_clus = ((fid->size - 1) >> fsi->cluster_size_bits) + 1;
+
+			fid->size = num_clus << fsi->cluster_size_bits;
+		}
+
+		/* Adjust flags and start_clu for correct zero-size cases */
+		if (fid->type == TYPE_FILE && fid->size == 0) {
 			fid->flags = (fsi->vol_type == EXFAT) ? 0x03 : 0x01;
 			fid->start_clu = CLUS_EOF;
-		} else {
-			fid->flags = fsi->fs_func->get_entry_flag(ep2);
-			fid->start_clu = fsi->fs_func->get_entry_clu0(ep2);
+		} else if (fsi->vol_type == EXFAT &&
+			   fid->type == TYPE_DIR && fid->size == 0) {
+			if (!IS_CLUS_FREE(fid->start_clu)) {
+				EMSG("%s: bogus directory: not zero cluster(%u), but zero size (p_dir : %u, entry : 0x%08x)",
+					__func__, fid->start_clu, fid->dir.dir, fid->entry);
+				sdfat_debug_bug_on(1);
+			}
+			fid->flags = 0x03;
+			fid->start_clu = CLUS_EOF;
 		}
 
 		if ((fid->type == TYPE_DIR) && (fsi->vol_type != EXFAT)) {
@@ -2803,7 +2857,8 @@ s32 fscore_rename(struct inode *old_parent_inode, FILE_ID_T *fid,
 		}
 
 		/* Free the clusters if new_inode is a dir(as if fscore_rmdir) */
-		if (new_entry_type == TYPE_DIR) {
+		if (new_entry_type == TYPE_DIR &&
+		    !IS_CLUS_EOF(new_fid->start_clu)) {
 			/* new_fid, new_clu_to_free */
 			CHAIN_T new_clu_to_free;
 
@@ -3597,7 +3652,14 @@ s32 fscore_readdir(struct inode *inode, DIR_ENTRY_T *dir_entry)
 					dir_entry->NameBuf.sfnbuf_len);
 			}
 
-			dir_entry->Size = fsi->fs_func->get_entry_size(ep);
+			if (fsi->fs_func->get_entry_validsize) {
+				dir_entry->Size = fsi->fs_func->get_entry_validsize(ep);
+
+				if (dir_entry->Size == 0 && type == TYPE_DIR)
+					dir_entry->Size = fsi->fs_func->get_entry_size(ep);
+			} else {
+				dir_entry->Size = fsi->fs_func->get_entry_size(ep);
+			}
 
 			/*
 			 * Update hint information :
diff --git a/fs/sdfat/core_exfat.c b/fs/sdfat/core_exfat.c
index b5e65646eb35..08d713dda767 100644
--- a/fs/sdfat/core_exfat.c
+++ b/fs/sdfat/core_exfat.c
@@ -209,9 +209,16 @@ static u64 exfat_get_entry_size(DENTRY_T *p_entry)
 {
 	STRM_DENTRY_T *ep = (STRM_DENTRY_T *)p_entry;
 
-	return le64_to_cpu(ep->valid_size);
+	return le64_to_cpu(ep->size);
 } /* end of exfat_get_entry_size */
 
+static u64 exfat_get_entry_validsize(DENTRY_T *p_entry)
+{
+	STRM_DENTRY_T *ep = (STRM_DENTRY_T *)p_entry;
+
+	return le64_to_cpu(ep->valid_size);
+} /* end of exfat_get_entry_validsize */
+
 static void exfat_set_entry_size(DENTRY_T *p_entry, u64 size)
 {
 	STRM_DENTRY_T *ep = (STRM_DENTRY_T *)p_entry;
@@ -601,7 +608,7 @@ ENTRY_SET_CACHE_T *get_dentry_set_in_dir(struct super_block *sb,
 
 	MMSG("trying to malloc %lx bytes for %d entries\n",
 		(unsigned long)(offsetof(ENTRY_SET_CACHE_T, __buf) + (num_entries)  * sizeof(DENTRY_T)), num_entries);
-	es = kmalloc((offsetof(ENTRY_SET_CACHE_T, __buf) + (num_entries)  * sizeof(DENTRY_T)), GFP_KERNEL);
+	es = kmalloc((offsetof(ENTRY_SET_CACHE_T, __buf) + (num_entries)  * sizeof(DENTRY_T)), GFP_NOFS);
 	if (!es) {
 		EMSG("%s: failed to alloc entryset\n", __func__);
 		goto err_out;
@@ -1512,6 +1519,7 @@ static FS_FUNC_T exfat_fs_func = {
 	.get_entry_clu0 = exfat_get_entry_clu0,
 	.set_entry_clu0 = exfat_set_entry_clu0,
 	.get_entry_size = exfat_get_entry_size,
+	.get_entry_validsize = exfat_get_entry_validsize,
 	.set_entry_size = exfat_set_entry_size,
 	.get_entry_time = exfat_get_entry_time,
 	.set_entry_time = exfat_set_entry_time,
diff --git a/fs/sdfat/core_fat.c b/fs/sdfat/core_fat.c
index ca2839b04b87..bdf1d19c0b51 100644
--- a/fs/sdfat/core_fat.c
+++ b/fs/sdfat/core_fat.c
@@ -1205,6 +1205,7 @@ static FS_FUNC_T fat_fs_func = {
 	.set_entry_flag = fat_set_entry_flag,
 	.get_entry_clu0 = fat_get_entry_clu0,
 	.set_entry_clu0 = fat_set_entry_clu0,
+	.get_entry_validsize = NULL,
 	.get_entry_size = fat_get_entry_size,
 	.set_entry_size = fat_set_entry_size,
 	.get_entry_time = fat_get_entry_time,
@@ -1233,6 +1234,7 @@ static FS_FUNC_T amap_fat_fs_func = {
 	.set_entry_flag = fat_set_entry_flag,
 	.get_entry_clu0 = fat_get_entry_clu0,
 	.set_entry_clu0 = fat_set_entry_clu0,
+	.get_entry_validsize = NULL,
 	.get_entry_size = fat_get_entry_size,
 	.set_entry_size = fat_set_entry_size,
 	.get_entry_time = fat_get_entry_time,
diff --git a/fs/sdfat/misc.c b/fs/sdfat/misc.c
index 262e28ee023d..9672004d7675 100644
--- a/fs/sdfat/misc.c
+++ b/fs/sdfat/misc.c
@@ -71,7 +71,11 @@ static struct kobject sdfat_uevent_kobj;
 int sdfat_uevent_init(struct kset *sdfat_kset)
 {
 	int err;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0)
+	const struct kobj_type *ktype = get_ktype(&sdfat_kset->kobj);
+#else
 	struct kobj_type *ktype = get_ktype(&sdfat_kset->kobj);
+#endif
 
 	sdfat_uevent_kobj.kset = sdfat_kset;
 	err = kobject_init_and_add(&sdfat_uevent_kobj, ktype, NULL, "uevent");
@@ -242,6 +246,13 @@ static time_t accum_days_in_year[] = {
 	0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 0, 0, 0,
 };
 
+static inline int sdfat_tz_offset(struct sdfat_sb_info *sbi)
+{
+	if (sbi->options.tz_set)
+		return -sbi->options.time_offset;
+	return sys_tz.tz_minuteswest;
+}
+
 #define TIMEZONE_SEC(x)	((x) * 15 * SECS_PER_MIN)
 /* Convert a FAT time/date pair to a UNIX date (seconds since 1 1 70). */
 void sdfat_time_fat2unix(struct sdfat_sb_info *sbi, sdfat_timespec_t *ts,
@@ -262,16 +273,12 @@ void sdfat_time_fat2unix(struct sdfat_sb_info *sbi, sdfat_timespec_t *ts,
 
 	ts->tv_nsec = 0;
 
-	/* Treat as local time */
-	if (!sbi->options.tz_utc && !tp->Timezone.valid) {
-		ts->tv_sec += sys_tz.tz_minuteswest * SECS_PER_MIN;
+	/* Treat as local time or UTC with time_offset */
+	if (!tp->Timezone.valid) {
+		ts->tv_sec += sdfat_tz_offset(sbi) * SECS_PER_MIN;
 		return;
 	}
 
-	/* Treat as UTC time */
-	if (!tp->Timezone.valid)
-		return;
-
 	/* Treat as UTC time, but need to adjust timezone to UTC0 */
 	if (tp->Timezone.off <= 0x3F)
 		ts->tv_sec -= TIMEZONE_SEC(tp->Timezone.off);
@@ -291,13 +298,13 @@ void sdfat_time_unix2fat(struct sdfat_sb_info *sbi, sdfat_timespec_t *ts,
 
 	tp->Timezone.value = 0x00;
 
-	/* Treats as local time with proper time */
-	if (tz_valid || !sbi->options.tz_utc) {
-		second -= sys_tz.tz_minuteswest * SECS_PER_MIN;
-		if (tz_valid) {
-			tp->Timezone.valid = 1;
-			tp->Timezone.off = TIMEZONE_CUR_OFFSET();
-		}
+	/* Always set as UTC0 */
+	if (tz_valid) {
+		tp->Timezone.valid = 1;
+		tp->Timezone.off = 0;
+	} else {
+		/* Treats as local time with proper time */
+		second -= sdfat_tz_offset(sbi) * SECS_PER_MIN;
 	}
 
 	/* Jan 1 GMT 00:00:00 1980. But what about another time zone? */
diff --git a/fs/sdfat/mpage.c b/fs/sdfat/mpage.c
index 10a802d7d325..19dfb11073fb 100644
--- a/fs/sdfat/mpage.c
+++ b/fs/sdfat/mpage.c
@@ -111,13 +111,13 @@ static inline int wbc_to_write_flags(struct writeback_control *wbc)
 #endif
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
-static inline void __sdfat_submit_bio_write2(int flags, struct bio *bio)
+static inline void __sdfat_write_submit_bio_2(int flags, struct bio *bio)
 {
 	bio_set_op_attrs(bio, REQ_OP_WRITE, flags);
 	submit_bio(bio);
 }
 #else /* LINUX_VERSION_CODE < KERNEL_VERSION(4,8,0) */
-static inline void __sdfat_submit_bio_write2(int flags, struct bio *bio)
+static inline void __sdfat_write_submit_bio_2(int flags, struct bio *bio)
 {
 	submit_bio(WRITE | flags, bio);
 }
@@ -336,12 +336,35 @@ static void __mpage_write_end_io(struct bio *bio, int err)
 static struct bio *mpage_bio_submit_write(int flags, struct bio *bio)
 {
 	bio->bi_end_io = mpage_write_end_io;
-	__sdfat_submit_bio_write2(flags, bio);
+	__sdfat_write_submit_bio_2(flags, bio);
 	return NULL;
 }
 
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+static struct bio *
+mpage_alloc(struct block_device *bdev, struct writeback_control *wbc,
+		sector_t first_sector, int nr_vecs,
+		gfp_t gfp_flags)
+{
+	unsigned int flags = REQ_OP_WRITE | wbc_to_write_flags(wbc);
+	struct bio *bio;
+
+	bio = bio_alloc(bdev, nr_vecs, flags, gfp_flags);
+
+	if (bio == NULL && (current->flags & PF_MEMALLOC)) {
+		while (!bio && (nr_vecs /= 2))
+			bio = bio_alloc(bdev, nr_vecs, flags, gfp_flags);
+	}
+
+	if (bio)
+		__sdfat_set_bio_sector(bio, first_sector);
+
+	return bio;
+}
+#else
 static struct bio *
-mpage_alloc(struct block_device *bdev,
+mpage_alloc(struct block_device *bdev, struct writeback_control *wbc,
 		sector_t first_sector, int nr_vecs,
 		gfp_t gfp_flags)
 {
@@ -360,6 +383,7 @@ mpage_alloc(struct block_device *bdev,
 	}
 	return bio;
 }
+#endif
 
 
 #if IS_BUILTIN(CONFIG_SDFAT_FS)
@@ -394,6 +418,10 @@ static void __write_boundary_block(struct block_device *bdev,
 #define sdfat_buffer_heads_over_limit	(0)
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 19, 0)
+#define page_folio(p)	(p)
+#endif
+
 static void clean_buffers(struct page *page, unsigned int first_unmapped)
 {
 	unsigned int buffer_counter = 0;
@@ -416,8 +444,9 @@ static void clean_buffers(struct page *page, unsigned int first_unmapped)
 	 * readpage would fail to serialize with the bh and it would read from
 	 * disk before we reach the platter.
 	 */
+
 	if (sdfat_buffer_heads_over_limit && PageUptodate(page))
-		try_to_free_buffers(page);
+		try_to_free_buffers(page_folio(page));
 }
 
 static int sdfat_mpage_writepage(struct page *page,
@@ -624,7 +653,7 @@ static int sdfat_mpage_writepage(struct page *page,
 
 alloc_new:
 	if (!bio) {
-		bio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),
+		bio = mpage_alloc(bdev, wbc, blocks[0] << (blkbits - 9),
 				bio_get_nr_vecs(bdev), GFP_NOFS|__GFP_HIGH);
 		if (!bio)
 			goto confused;
diff --git a/fs/sdfat/sdfat.c b/fs/sdfat/sdfat.c
index 337066fb4c61..184884edb462 100644
--- a/fs/sdfat/sdfat.c
+++ b/fs/sdfat/sdfat.c
@@ -151,21 +151,11 @@ static void sdfat_setattr_copy(struct inode *inode, struct iattr *attr)
 {
 	setattr_copy(&init_user_ns, inode, attr);
 }
-
-static u32 sdfat_make_inode_generation(void)
-{
-	return prandom_u32();
-}
 #else
 static void sdfat_setattr_copy(struct inode *inode, struct iattr *attr)
 {
 	setattr_copy(inode, attr);
 }
-
-static u32 sdfat_make_inode_generation(void)
-{
-	return (u32)get_seconds();
-}
 #endif
 
 
@@ -213,9 +203,35 @@ static inline int wbc_to_write_flags(struct writeback_control *wbc)
 }
 #endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+static inline struct bio *__sdfat_write_bio_alloc(struct block_device *bdev,
+		struct writeback_control *wbc,
+		unsigned short nr_vecs, gfp_t gfp_mask)
+{
+	int write_flags = wbc_to_write_flags(wbc);
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
-static inline void __sdfat_submit_bio_write(struct bio *bio,
+	return bio_alloc(bdev, nr_vecs, REQ_OP_WRITE | write_flags, gfp_mask);
+}
+
+static inline void __sdfat_write_submit_bio(struct bio *bio,
+					    struct writeback_control *wbc)
+{
+	submit_bio(bio);
+}
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
+static inline struct bio *__sdfat_write_bio_alloc(struct block_device *bdev,
+		struct writeback_control *wbc,
+		unsigned short nr_vecs, gfp_t gfp_mask)
+{
+	struct bio *bio = bio_alloc(gfp_mask, nr_vecs);
+
+	if (bio)
+		bio_set_dev(bio, bdev);
+
+	return bio;
+}
+
+static inline void __sdfat_write_submit_bio(struct bio *bio,
 					    struct writeback_control *wbc)
 {
 	int write_flags = wbc_to_write_flags(wbc);
@@ -223,7 +239,29 @@ static inline void __sdfat_submit_bio_write(struct bio *bio,
 	bio_set_op_attrs(bio, REQ_OP_WRITE, write_flags);
 	submit_bio(bio);
 }
+#else /* LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0) */
+static inline struct bio *__sdfat_write_bio_alloc(struct block_device *bdev,
+		struct writeback_control *wbc,
+		unsigned short nr_vecs, gfp_t gfp_mask)
+{
+	struct bio *bio = bio_alloc(gfp_mask, nr_vecs);
+
+	if (bio)
+		bio_set_dev(bio, bdev);
+
+	return bio;
+}
 
+static inline void __sdfat_write_submit_bio(struct bio *bio,
+					    struct writeback_control *wbc)
+{
+	int write_flags = wbc_to_write_flags(wbc);
+
+	submit_bio(WRITE | write_flags, bio);
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
 static inline unsigned int __sdfat_full_name_hash(const struct dentry *dentry, const char *name, unsigned int len)
 {
 	return full_name_hash(dentry, name, len);
@@ -234,14 +272,6 @@ static inline unsigned long __sdfat_init_name_hash(const struct dentry *dentry)
 	return init_name_hash(dentry);
 }
 #else /* LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0) */
-static inline void __sdfat_submit_bio_write(struct bio *bio,
-					    struct writeback_control *wbc)
-{
-	int write_flags = wbc_to_write_flags(wbc);
-
-	submit_bio(WRITE | write_flags, bio);
-}
-
 static inline unsigned int __sdfat_full_name_hash(const struct dentry *unused, const char *name, unsigned int len)
 {
 	return full_name_hash(name, len);
@@ -900,6 +930,23 @@ static int sdfat_file_fsync(struct file *filp, int datasync)
 /*************************************************************************
  * MORE FUNCTIONS WHICH HAS KERNEL VERSION DEPENDENCY
  *************************************************************************/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
+static u32 sdfat_make_inode_generation(void)
+{
+	return get_random_u32();
+}
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+static u32 sdfat_make_inode_generation(void)
+{
+	return prandom_u32();
+}
+#else /* LINUX_VERSION_CODE < KERNEL_VERSION(5, 12, 0) */
+static u32 sdfat_make_inode_generation(void)
+{
+	return (u32)get_seconds();
+}
+#endif
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
 static int sdfat_getattr(struct user_namespace *mnt_uerns,
 		const struct path *path, struct kstat *stat,
@@ -2600,13 +2647,19 @@ static struct dentry *__sdfat_lookup(struct inode *dir, struct dentry *dentry)
 
 	i_mode = inode->i_mode;
 	if (S_ISLNK(i_mode) && !SDFAT_I(inode)->target) {
-		SDFAT_I(inode)->target = kmalloc((i_size_read(inode)+1), GFP_KERNEL);
+		u64 path_len = i_size_read(inode);
+
+		if (path_len >= PATH_MAX)
+			path_len = PATH_MAX - 1;
+
+		SDFAT_I(inode)->target = kmalloc((path_len + 1), GFP_NOFS);
 		if (!SDFAT_I(inode)->target) {
 			err = -ENOMEM;
+			iput(inode);
 			goto error;
 		}
-		fsapi_read_link(dir, &fid, SDFAT_I(inode)->target, i_size_read(inode), &ret);
-		*(SDFAT_I(inode)->target + i_size_read(inode)) = '\0';
+		fsapi_read_link(dir, &fid, SDFAT_I(inode)->target, path_len, &ret);
+		*(SDFAT_I(inode)->target + path_len) = '\0';
 	}
 
 	alias = d_find_alias(inode);
@@ -2755,7 +2808,7 @@ static int __sdfat_symlink(struct inode *dir, struct dentry *dentry,
 	inode->i_mtime = inode->i_atime = inode->i_ctime = ts;
 	/* timestamp is already written, so mark_inode_dirty() is unneeded. */
 
-	SDFAT_I(inode)->target = kmalloc((len+1), GFP_KERNEL);
+	SDFAT_I(inode)->target = kmalloc((len+1), GFP_NOFS);
 	if (!SDFAT_I(inode)->target) {
 		err = -ENOMEM;
 		goto out;
@@ -3627,6 +3680,15 @@ static int sdfat_get_block(struct inode *inode, sector_t iblock,
 	return err;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 0)
+static int sdfat_read_folio(struct file *file, struct folio *folio)
+{
+	int ret;
+
+	ret =  mpage_read_folio(folio, sdfat_get_block);
+	return ret;
+}
+#else
 static int sdfat_readpage(struct file *file, struct page *page)
 {
 	int ret;
@@ -3634,6 +3696,7 @@ static int sdfat_readpage(struct file *file, struct page *page)
 	ret =  mpage_readpage(page, sdfat_get_block);
 	return ret;
 }
+#endif
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
 static void sdfat_readahead(struct readahead_control *rac)
@@ -3667,9 +3730,8 @@ static inline void sdfat_submit_fullpage_bio(struct block_device *bdev,
 	 *
 	 * #define GFP_NOIO	(__GFP_WAIT)
 	 */
-	bio = bio_alloc(GFP_NOIO, 1);
+	bio = __sdfat_write_bio_alloc(bdev, wbc, 1, GFP_NOIO);
 
-	bio_set_dev(bio, bdev);
 	bio->bi_vcnt = 1;
 	bio->bi_io_vec[0].bv_page = page;	/* Inline vec */
 	bio->bi_io_vec[0].bv_len = length;	/* PAGE_SIZE */
@@ -3677,7 +3739,7 @@ static inline void sdfat_submit_fullpage_bio(struct block_device *bdev,
 	__sdfat_set_bio_iterate(bio, sector, length, 0, 0);
 
 	bio->bi_end_io = sdfat_writepage_end_io;
-	__sdfat_submit_bio_write(bio, wbc);
+	__sdfat_write_submit_bio(bio, wbc);
 }
 
 static int sdfat_writepage(struct page *page, struct writeback_control *wbc)
@@ -3899,8 +3961,13 @@ static int __sdfat_write_begin(struct file *file, struct address_space *mapping,
 		return ret;
 
 	*pagep = NULL;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 0)
+	ret = cont_write_begin(file, mapping, pos, len, pagep, fsdata,
+					get_block, bytes);
+#else
 	ret = cont_write_begin(file, mapping, pos, len, flags, pagep, fsdata,
 					get_block, bytes);
+#endif
 
 	if (ret < 0)
 		sdfat_write_failed(mapping, pos+len);
@@ -3908,7 +3975,28 @@ static int __sdfat_write_begin(struct file *file, struct address_space *mapping,
 	return ret;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 0)
+static int sdfat_da_write_begin(struct file *file, struct address_space *mapping,
+				 loff_t pos, unsigned int len,
+				 struct page **pagep, void **fsdata)
+{
+	return __sdfat_write_begin(file, mapping, pos, len, 0,
+				pagep, fsdata, sdfat_da_prep_block,
+				&SDFAT_I(mapping->host)->i_size_aligned,
+				__func__);
+}
+
 
+static int sdfat_write_begin(struct file *file, struct address_space *mapping,
+				 loff_t pos, unsigned int len,
+				 struct page **pagep, void **fsdata)
+{
+	return __sdfat_write_begin(file, mapping, pos, len, 0,
+				pagep, fsdata, sdfat_get_block,
+				&SDFAT_I(mapping->host)->i_size_ondisk,
+				__func__);
+}
+#else /* LINUX_VERSION_CODE < KERNEL_VERSION(5, 19, 0) */
 static int sdfat_da_write_begin(struct file *file, struct address_space *mapping,
 				 loff_t pos, unsigned int len, unsigned int flags,
 				 struct page **pagep, void **fsdata)
@@ -3929,6 +4017,7 @@ static int sdfat_write_begin(struct file *file, struct address_space *mapping,
 				&SDFAT_I(mapping->host)->i_size_ondisk,
 				__func__);
 }
+#endif
 
 static int sdfat_write_end(struct file *file, struct address_space *mapping,
 				   loff_t pos, unsigned int len, unsigned int copied,
@@ -3994,7 +4083,19 @@ static inline ssize_t __sdfat_direct_IO(int rw, struct kiocb *iocb,
 }
 
 static const struct address_space_operations sdfat_aops = {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	.dirty_folio = block_dirty_folio,
+	.invalidate_folio = block_invalidate_folio,
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 14, 0)
+	.set_page_dirty = __set_page_dirty_buffers,
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 0)
+	.read_folio  = sdfat_read_folio,
+#else
 	.readpage    = sdfat_readpage,
+#endif
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
 	.readahead   = sdfat_readahead,
 #else
@@ -4009,7 +4110,19 @@ static const struct address_space_operations sdfat_aops = {
 };
 
 static const struct address_space_operations sdfat_da_aops = {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	.dirty_folio    = block_dirty_folio,
+	.invalidate_folio = block_invalidate_folio,
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 14, 0)
+	.set_page_dirty = __set_page_dirty_buffers,
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 0)
+	.read_folio     = sdfat_read_folio,
+#else
 	.readpage    = sdfat_readpage,
+#endif
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
 	.readahead   = sdfat_readahead,
 #else
@@ -4075,6 +4188,12 @@ static int sdfat_fill_inode(struct inode *inode, const FILE_ID_T *fid)
 		return -EIO;
 	}
 
+	/* symlink option check */
+	if (!sbi->options.symlink) {
+		info.Attr &= ~(ATTR_SYMLINK);
+		SDFAT_I(inode)->fid.attr &= ~(ATTR_SYMLINK);
+	}
+
 	if (info.Attr & ATTR_SUBDIR) { /* directory */
 		inode->i_generation &= ~1;
 		inode->i_mode = sdfat_make_mode(sbi, info.Attr, S_IRWXUGO);
@@ -4282,11 +4401,14 @@ static void sdfat_free_sb_info(struct sdfat_sb_info *sbi)
 		sbi->options.iocharset = sdfat_default_iocharset;
 	}
 
-	if (sbi->use_vmalloc) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+	kvfree(sbi);
+#else
+	if (!sbi->use_vmalloc)
+		kfree(sbi);
+	else
 		vfree(sbi);
-		return;
-	}
-	kfree(sbi);
+#endif
 }
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
@@ -4556,8 +4678,12 @@ static int __sdfat_show_options(struct seq_file *m, struct super_block *sb)
 	if (sbi->fsi.vol_type != EXFAT)
 		seq_puts(m, ",shortname=winnt");
 	seq_printf(m, ",namecase=%u", opts->casesensitive);
-	if (opts->tz_utc)
-		seq_puts(m, ",tz=UTC");
+	if (opts->tz_set) {
+		if (opts->time_offset)
+			seq_printf(m, ",time_offset=%d", opts->time_offset);
+		else
+			seq_puts(m, ",tz=UTC");
+	}
 	if (opts->improved_allocation & SDFAT_ALLOC_DELAY)
 		seq_puts(m, ",delay");
 	if (opts->improved_allocation & SDFAT_ALLOC_SMART)
@@ -4713,10 +4839,19 @@ static struct attribute *sdfat_attrs[] = {
 	NULL,
 };
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+ATTRIBUTE_GROUPS(sdfat);
+
+static struct kobj_type sdfat_ktype = {
+	.default_groups = sdfat_groups,
+	.sysfs_ops     = &sdfat_attr_ops,
+};
+#else
 static struct kobj_type sdfat_ktype = {
 	.default_attrs = sdfat_attrs,
 	.sysfs_ops     = &sdfat_attr_ops,
 };
+#endif
 
 static ssize_t version_show(struct kobject *kobj,
 		struct kobj_attribute *attr, char *buff)
@@ -4749,6 +4884,7 @@ enum {
 	Opt_codepage,
 	Opt_charset,
 	Opt_utf8,
+	Opt_time_offset,
 	Opt_namecase,
 	Opt_tz_utc,
 	Opt_adj_hidsect,
@@ -4780,6 +4916,7 @@ static const match_table_t sdfat_tokens = {
 	{Opt_utf8, "utf8"},
 	{Opt_namecase, "namecase=%u"},
 	{Opt_tz_utc, "tz=UTC"},
+	{Opt_time_offset, "time_offset=%d"},
 	{Opt_adj_hidsect, "adj_hid"},
 	{Opt_delay, "delay"},
 	{Opt_smart, "smart"},
@@ -4797,6 +4934,26 @@ static const match_table_t sdfat_tokens = {
 	{Opt_err, NULL}
 };
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 0)
+static inline bool __sdfat_can_support_discard(struct block_device *bdev)
+{
+	if (!bdev_max_discard_sectors(bdev))
+		return false;
+
+	return true;
+}
+#else
+static inline bool __sdfat_can_support_discard(struct block_device *bdev)
+{
+	struct request_queue *q = bdev_get_queue(bdev);
+
+	if (!blk_queue_discard(q))
+		return false;
+
+	return true;
+}
+#endif
+
 static int parse_options(struct super_block *sb, char *options, int silent,
 				int *debug, struct sdfat_mount_options *opts)
 {
@@ -4814,7 +4971,8 @@ static int parse_options(struct super_block *sb, char *options, int silent,
 	opts->casesensitive = 0;
 	opts->utf8 = 0;
 	opts->adj_hidsect = 0;
-	opts->tz_utc = 0;
+	opts->tz_set = 0;
+	opts->time_offset = 0;
 	opts->improved_allocation = 0;
 	opts->amap_opt.pack_ratio = 0;	// Default packing
 	opts->amap_opt.sect_per_au = 0;
@@ -4884,7 +5042,21 @@ static int parse_options(struct super_block *sb, char *options, int silent,
 			opts->adj_hidsect = 1;
 			break;
 		case Opt_tz_utc:
-			opts->tz_utc = 1;
+			opts->tz_set = 1;
+			opts->time_offset = 0;
+			break;
+		case Opt_time_offset:
+			if (match_int(&args[0], &option))
+				return -EINVAL;
+			/*
+			 * GMT+-12 zones may have DST corrections so at least
+			 * 13 hours difference is needed. Make the limit 24
+			 * just in case someone invents something unusual.
+			 */
+			if (option < -24 * 60 || option > 24 * 60)
+				return -EINVAL;
+			opts->tz_set = 1;
+			opts->time_offset = option;
 			break;
 		case Opt_symlink:
 			if (match_int(&args[0], &option))
@@ -4981,9 +5153,7 @@ static int parse_options(struct super_block *sb, char *options, int silent,
 	}
 
 	if (opts->discard) {
-		struct request_queue *q = bdev_get_queue(sb->s_bdev);
-
-		if (!blk_queue_discard(q))
+		if (!__sdfat_can_support_discard(sb->s_bdev))
 			sdfat_msg(sb, KERN_WARNING,
 				"mounting with \"discard\" option, but "
 				"the device does not support discard");
@@ -5082,6 +5252,13 @@ static int sdfat_fill_super(struct super_block *sb, void *data, int silent)
 	 * the filesystem, since we're only just about to mount
 	 * it and have no inodes etc active!
 	 */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+	sbi = kvzalloc(sizeof(struct sdfat_sb_info), GFP_KERNEL);
+	if (!sbi) {
+		sdfat_log_msg(sb, KERN_ERR, "failed to mount! (ENOMEM)");
+		return -ENOMEM;
+	}
+#else
 	sbi = kzalloc(sizeof(struct sdfat_sb_info), GFP_KERNEL);
 	if (!sbi) {
 		sdfat_log_msg(sb, KERN_INFO,
@@ -5093,6 +5270,7 @@ static int sdfat_fill_super(struct super_block *sb, void *data, int silent)
 		}
 		sbi->use_vmalloc = 1;
 	}
+#endif
 
 	mutex_init(&sbi->s_vlock);
 	sb->s_fs_info = sbi;
@@ -5221,10 +5399,14 @@ static int sdfat_fill_super(struct super_block *sb, void *data, int silent)
 	if (sbi->options.iocharset != sdfat_default_iocharset)
 		kfree(sbi->options.iocharset);
 	sb->s_fs_info = NULL;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+	kvfree(sbi);
+#else
 	if (!sbi->use_vmalloc)
 		kfree(sbi);
 	else
 		vfree(sbi);
+#endif
 	return err;
 }
 
@@ -5300,20 +5482,6 @@ static struct file_system_type sdfat_fs_type = {
 	.fs_flags    = FS_REQUIRES_DEV,
 };
 
-#ifdef CONFIG_SDFAT_USE_FOR_EXFAT
-static struct file_system_type exfat_fs_type = {
-	.owner       = THIS_MODULE,
-	.name        = "exfat",
-	.mount       = sdfat_fs_mount,
-#ifdef CONFIG_SDFAT_DBG_IOCTL
-	.kill_sb    = sdfat_debug_kill_sb,
-#else
-	.kill_sb    = kill_block_super,
-#endif /* CONFIG_SDFAT_DBG_IOCTL */
-	.fs_flags    = FS_REQUIRES_DEV,
-};
-#endif /* CONFIG_SDFAT_USE_FOR_EXFAT */
-
 static int __init init_sdfat_fs(void)
 {
 	int err;
@@ -5356,14 +5524,6 @@ static int __init init_sdfat_fs(void)
 		goto error;
 	}
 
-#ifdef CONFIG_SDFAT_USE_FOR_EXFAT
-	err = register_filesystem(&exfat_fs_type);
-	if (err) {
-		pr_err("[SDFAT] failed to register for exfat filesystem\n");
-		goto error;
-	}
-#endif /* CONFIG_SDFAT_USE_FOR_EXFAT */
-
 	return 0;
 error:
 	sdfat_uevent_uninit();
@@ -5402,9 +5562,7 @@ static void __exit exit_sdfat_fs(void)
 
 	sdfat_destroy_inodecache();
 	unregister_filesystem(&sdfat_fs_type);
-#ifdef CONFIG_SDFAT_USE_FOR_EXFAT
-	unregister_filesystem(&exfat_fs_type);
-#endif /* CONFIG_SDFAT_USE_FOR_EXFAT */
+
 	fsapi_shutdown();
 }
 
diff --git a/fs/sdfat/sdfat.h b/fs/sdfat/sdfat.h
index 8a18aa5b798e..57cedad10503 100644
--- a/fs/sdfat/sdfat.h
+++ b/fs/sdfat/sdfat.h
@@ -120,7 +120,8 @@ struct sdfat_mount_options {
 	unsigned char utf8;
 	unsigned char casesensitive;
 	unsigned char adj_hidsect;
-	unsigned char tz_utc;
+	unsigned char tz_set;
+	int time_offset;
 	unsigned char improved_allocation;
 	unsigned char defrag;
 	unsigned char symlink;      /* support symlink operation */
@@ -481,13 +482,13 @@ extern struct timeval __t2;
 #define SDFAT_MSG_LEVEL		SDFAT_MSG_LV_INFO
 
 #define SDFAT_TAG_NAME	"SDFAT"
-#define __S(x) #x
-#define _S(x) __S(x)
+#define ___S(x) #x
+#define __S(x) ___S(x)
 
 extern void __sdfat_dmsg(int level, const char *fmt, ...) __printf(2, 3) __cold;
 
 #define SDFAT_EMSG_T(level, ...)	\
-	__sdfat_dmsg(level, KERN_ERR "[" SDFAT_TAG_NAME "] [" _S(__FILE__) "(" _S(__LINE__) ")] " __VA_ARGS__)
+	__sdfat_dmsg(level, KERN_ERR "[" SDFAT_TAG_NAME "] [" __S(__FILE__) "(" __S(__LINE__) ")] " __VA_ARGS__)
 #define SDFAT_DMSG_T(level, ...)	\
 	__sdfat_dmsg(level, KERN_INFO "[" SDFAT_TAG_NAME "] " __VA_ARGS__)
 
diff --git a/fs/sdfat/version.h b/fs/sdfat/version.h
index 4f2b997de35e..0dbe157413bb 100644
--- a/fs/sdfat/version.h
+++ b/fs/sdfat/version.h
@@ -23,5 +23,5 @@
 /*                                                                      */
 /************************************************************************/
 
-/* @fs.sec -- 8304f2146e71f0f27864eebd58892260 -- */
-#define SDFAT_VERSION	"2.6.0"
+/* @fs.sec -- 8304f2146e71f0f27864eebd58892281 -- */
+#define SDFAT_VERSION	"2.8.1"
